参考：  
[手把手教你开发生产级 IM 系统](https://mp.weixin.qq.com/s/_Direcn6tk2P2KDpncFdgQ)
[从零开始搭建瓜子 IM 系统](https://mp.weixin.qq.com/s/TUIxcg0EJC0S26gKrKqYKg)  
[一个海量在线用户即时通讯系统（IM）的完整设计](https://mp.weixin.qq.com/s?__biz=MzI1ODY0NjAwMA==&mid=2247483756&idx=1&sn=a8e3303bc573b1acaf9ef3862ef89bdd&chksm=ea044bf3dd73c2e5dcf2c10202c66d6143ec866205e9230f974fbc0b0be587926699230b6b18#rd)  
[基于消息总线的高可扩展性 IM 系统后台架构设计](https://mp.weixin.qq.com/s/a4sDH48PWTHax2uBej1Jtg)  
[低成本确保消息时序的方法](https://mp.weixin.qq.com/s/QtlgYtfek4Sv8Ss5b8ojxA)  
[别人读没读你的消息，你如何知道？](https://mp.weixin.qq.com/s/4URbQUeyTOcm1xtTwfjqUA)  
[ID 生成策略——SnowFlake](https://mp.weixin.qq.com/s/p_cANKSn5hFxHo-YzzYs-A)  
[架构成长之路：9 种高性能高可用高并发的技术架构](https://www.jianshu.com/p/b067266bbdf4)  
[golang 写的 IM 服务器](https://github.com/alberliu/goim)  
[goim v2.0-高性能聊天室](https://github.com/Terry-Mao/goim)  
[快速裂变：见证微信强大后台架构从 0 到 1 的演进历程（一）](http://www.52im.net/thread-168-1-1.html)  
[今日头条架构演进之路——高压下的架构演进专题](https://www.jianshu.com/p/6c879e132093)  
[微信技术分享：微信的海量 IM 聊天消息序列号生成实践（算法原理篇）](http://www.52im.net/thread-1998-1-1.html)

特别感谢公众号：普通程序员，**封宇**大神的系列IM分享文章🙏。

# 1 服务端设计

## 1.1 总体架构

![架构](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/architecture.png)

## 1.2 逻辑架构

![架构](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/architecture2.png)

客户端从Iplist服务获取接入层IP地址（也可采用域名的方式解析得到接入层IP地址），建立与接入层的连接（可能为短连接），从而实现客户端与IM服务器的数据交互；业务线服务器可以通过服务器端API建立与IM服务器的联系，向客户端推送消息；客户端上报到业务服务器的消息，IM服务器会通过mq投递给业务服务器。

### 1.2.1 用户端

移动端以 iOS 为主，全部使用 Swift 编写。后续增加顺序可能是：Flutter->Android->WebSocket 等客户端。客户端主要用来演示 SDK 功能，后续根据场景可能会考虑增加如电商、教育等 demo。

### 1.2.2 用户端 API

针对 TCP 协议，提供 IOS/Android 开发 SDK。对于 H5 页面，提供 WebSocket 接口

### 1.2.3 接入层

接入层主要任务是保持海量用户连接（接入）、攻击防护、将海量连接整流成少量 TCP 连接与逻辑层通讯。

### 1.2.4 逻辑层

逻辑层负责 IM 系统各项功能的核心逻辑实现。包括单聊（c2c）、上报(c2s)、推送(s2c)、群聊(c2g)、离线消息、登录授权、组织机构树等等内容。

### 1.2.5 存储层

存储层负责缓存或存储 IM 系统相关数据，主要包括用户状态及路由（缓存），消息数据（MySQL 也可采用 NoSql，如 MangoDB），文件数据（文件服务器）。

## 1.3 模块架构

![模块架构](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/structure.png)  
除 Router 之外其他服务都是无状态设计，可以支持分布式部署。通常前期推荐每个服务部署双节点冗余，以提高可用性。

### 1.3.1 登录授权(auth)
![登录授权](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-login.png)  
AppServer：客户的应用服务器，非CoffeeChat提供  

1. 第三方帐号在用户注册时通过HTTP接口导入到CoffeeChat平台，传递UID、昵称（用来push推送时显示的昵称）、头像URL等。
2. 返回注册结果和token，token可以在app_server存储，直到用户修改密码后才被更新，以实现自动登录。
3. 客户端登录应用服务器，进行账号密码校验。
4. 应用服务器校验成功后，向msg_logic查询token。
5. msg_logic返回uid对应的token。
6. 客户端通过域名查询到msg_gate服务器地址（实现负载均衡）。
7. 客户端通过tcp连接msg_gate后，使用uid和token发起授权验证请求，msg_gate同步rpc调用msg_logic。
8. msg_logic验证token合法性，验证成功后把客户端状态记录在redis中并设置为在线。
9. msg_gate得到验证结果后，设置session状态，并向客户端返回验证结果。

### 1.3.2 登出(logout)
![登出](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-logout.png)  

1. 客户端向msg_gate发送登出请求。
2. msg_gate给客户端回复响应。
3. msg_gate通知msg_logci用户登出。

### 1.3.3 踢人(kickout)
暂不支持。

### 1.3.4 上报(c2s)
暂不支持。

### 1.3.5 推送(s2c)
![推送](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-s2c.png)  

1. 业务线调用push数据接口sendmsg
2. Logic向redis检索目标用户状态。如果目标用户不在线，丢弃数据（未来可根据业务场景定制化逻辑）；如果用户在线，查询到用户连接的接入层gate
3. Logic向用户所在的gate发送数据
4. Gate向用户推送数据。（如果用户不在线，通知logic用户不在线）
5. 客户端收到数据后向gate发送ack反馈
6. Gate将ack信息传递给logic层，用于其他可能的逻辑处理（如日志，确认送达等）

### 1.3.6 单聊(c2c)
![单聊](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-c2c.png)  

1. App1向gate1发送信息（信息最终要发给App2）
2. Gate1将信息投递给logic
3. Logic收到信息后，将信息进行存储
4. 存储成功后，logic向gate1发送ack
5. Gate1将ack信息发给App1
6. Logic检索redis，查找App2状态。如果App2未登录，流程结束
7. 如果App2登录到了gate2，logic将消息发往gate2
8. Gate2将消息发给App2（如果发现App2不在线，丢弃消息即可，这种概率极低，后续离线消息可保证消息不丢）
9. App2向gate2发送ack
10. Gate2将ack信息发给logic
11. Logic将消息状态设置为已送达。

注：在第6步和第7步之间，启动计时器（DelayedQueue或哈希环，时间如5秒），计时器时间到后，探测该条消息状态，如果消息未送达，考虑通过APNS、米推、个推进行推送

### 1.3.7 群聊(c2g)
采用扩散写（而非扩散读）的方式。  
群聊是多人社交的基本诉求，一个群友在群内发了一条消息：  
（1）在线的群友能第一时间收到消息  
（2）离线的群友能在登陆后收到消息  
由于“消息风暴扩散系数”的存在，群消息的复杂度要远高于单对单消息。  
群基础表：用来描述一个群的基本信息  
im_group_msgs(group_id, group_name,create_user, owner, announcement, create_time)  
群成员表：用来描述一个群里有多少成员  
im_group_users(group_id, user_id)  
用户接收消息表：用来描述一个用户的所有收到群消息（与单对单消息表是同一个表）  
im_message_recieve（msg_id,msg_from,msg_to, group_id，msg_seq, msg_content, send_time, msg_type, deliverd, cmd_id）  
用户发送消息表：用来描述一个用户发送了哪些消息  
im_message_send (msg_id,msg_from,msg_to, group_id，msg_seq, msg_content, send_time, msg_type, cmd_id)  
业务场景举例：  
（1）一个群中有x,A,B,C,D共5个成员，成员x发了一个消息  
（2）成员A与B在线，期望实时收到消息  
（3）成员C与D离线，期望未来拉取到离线消息  
群聊流程如下图所示  
![群聊](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-c2g.png)  
1. X向gate发送信息（信息最终要发给这个群，A、B在线）
2. Gate将消息发给logic
3. 存储消息到im_message_send表，按照msg_from水平分库
4. 回ack
5. 回ack
6. Logic检索数据库（需要使用缓存），获得群成员列表
7. 存储每个用户的消息数据（用户视图），按照msg_to水平分库(并发、批量写入)。
8. 查询用户在线状态及位置
9. Logic向gate投递消息
10. Gate向用户投递消息
11. App返回收到消息的ack信息
12. Gate向logic传递ack信息
13. 向缓存（Hash）中更新收到ack的时间。然后在通过一个定时任务，每隔一定时间，将数据更新到数据库（注意只需要写入时间段内有变化的数据）。

### 1.3.8 拉取离线消息(pull)

参考文章（基于TimeLine模型的消息同步机制 https://mp.weixin.qq.com/s/0eKfIRy8zpCpMrrF15Uigg）  
目前CoffeeChat基于简单的消息同步方法：
1. 把消息存储到mysql
2. 向在线用户推送消息（离线则走push通道）
3. 在线用户返回收到消息的ack信息

对于离线用户，登录后直接拉取离线消息即可，包含2部分：一次性查询会话列表和按需拉取某个会话下的历史聊天记录，后续再考虑增加基于TimeLine模型的消息同步功能。

#### 1）查询会话列表(session)，包含未读计数
![会话列表](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-session.png)  

1. 客户端向msg_gate请求会话列表。
2. msg_logic异步处理查询请求，通过线程池+消息队列的方式。
3. msg_logic从mysql中获取用户的所有会话列表，每个会话对应的最新消息id和内容等。
4. msg_logic从redis中补全每个会话的未读消息数量。
5. msg_logic回复响应。
6. msg_gate转发响应给客户端。

#### 2）查询历史消息(msglog)
![历史消息](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-msglog.png)  

1. App端登录成功，点击某个聊天后，向IM系统发起拉历史离线消息请求。传递3个主要参数，uid表明用户；end_msg_id表明当前收到的最小消息id（如果没收到过消息，或拿不到最小消息id则为0）即可；limit表示每次拉取条数（这个值也可以由服务器端控制）。
2. end_msg_id为0，查询最新的20条数据。
3. im_server查询用户前20条离线消息。
4. 将离线消息推给用户。假设这20条离线消息最后一条（最小）end_msg_id=110。
5. App得到数据，判断得到的数据不为空（消息数目返回的数值等于请求的limit），继续发起拉取操作。end_msg_id=110(取得到的离线消息中最后的一条，即ID最小的一条)。
6. 无。
7. 查询end_msg_id<110的钱20条离线数据。
8. 返回给App。
9. N-1查询end_msg_id>10的离线数据，不足20条（没有离线数据了）。 
10. N将数据返回App，App判断拉取不足20条数据，结束离线拉取过程。

注：上述是拉取所有聊天记录的完整过程，实际中是根据用户滑动操作按需拉取的。

## 1.2 推送平台

iOS：使用苹果官方的 APNS 推送，到达率有保障  
Android：  
第一种方案：根据手机来选择对应厂商的推送平台，比如华为、小米、OV、魅族等，到达率相对有保障，但是也会丢。  
第二种方案：也可以选择第三方厂商一键支持所有手机，比如极光、米推、个推，免费的效果很差并且有条数限制。  
第三种方案：可以选择真后台保活或者申请应用白名单。  
以上方案可以结合使用，总体而言，推送比较头疼。和微信、QQ等不能比，很多APP会彼此唤醒，手机厂商会选择把2者加入系统白名单等，所以才有那么高的消息到达率。

# 2 协议设计

## 2.1 协议组成
im协议包含协议头和数据部2部分。协议头通过结构体（类）序列化和反序列化实现，数据部使用protobuf描述。  
一个IM消息，在内存中是这样的：  
![协议组成](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/other-header.png)  

## 2.2 协议头设计
任何消息都由Header和Body2部分组成，Header部分是固定的，长度一定是16字节。而Body是可变的，通常由Header部分的cmd_id决定具体是什么含义。  

```c++
typedef struct {
    uint32_t    length;      // 无符号4字节，整包长度=16 + Body.Length()
    uint16_t    version;     // 无符号2字节，目前固定为1
    uint16_t    flag;        // 无符号2字节，标志位（预留）
    uint16_t    service_id;  // 无符号2字节，目标服务ID，以后可能用作路由（预留）
    uint16_t    command_id;  // 无符号2字节，0-65535，命令ID，用于如何解析body
    uint16_t    seq_num;  // 无符号2字节，0-65535，包序号
    uint16_t    reversed; // 无符号2字节，保留位
} CIMHeader_t;
```

## 2.3 数据部设计

具体见 pb 文件夹。  
CIMDef.proto：消息和数据模型定义  
CIMLogin.proto：登录认证业务。  
CIMList.proto：列表业务。会话（包括未读计数）、历史离线消息等  
CIMMessage.proto：消息业务。收发文本、图片、表情、声音、视频、文件、位置等  
### 2.3.1 认证授权

```protobuf
message CIMAuthTokenReq {
  // cmd id:		0x0101
  required uint64 user_id = 1;
  // CoffeeChat不存储用户信息，消息推送时需要显示昵称
  // 基于流量考虑，昵称不放在每条消息中携带
  // 但是如果期间用户更新昵称后，消息推送显示昵称会有延迟，CoffeeChat认为是能接受的
  required string nick_name = 2;
  required string user_token = 3;
  required CIMDef.CIMClientType client_type = 4;
  optional string client_version = 5;
}

// 用户信息
message CIMUserInfo {
  required uint64 user_id = 1;
  required string nick_name = 2;    // 用户昵称
  optional string attach_info = 11; // 自定义字段
}

message CIMAuthTokenRsp {
  // cmd id:		0x0102
  required uint32 server_time = 1;              // 服务器时间
  required CIMDef.CIMErrorCode result_code = 2; // 验证结果
  optional string result_string = 3;            // 结果描述
  optional CIMDef.CIMUserInfo user_info = 4;    // 用户信息
}
```

### 2.3.2 登出

```protobuf
message CIMLogoutReq {
  // cmd id:		0x0103
  required uint64 user_id = 1;
  required CIMDef.CIMClientType client_type = 2;
}

message CIMLogoutRsp {
  // cmd id:		0x0104
  required uint32 result_code = 1;
}
```

### 2.3.3 心跳
```protobuf
message CIMHeartBeat {
  // cmd id:		0x0105
}
```

### 2.3.4 消息

```protobuf
// 发送消息
message IMMsgData {
  // cmd id:		0x0301
  required uint64 from_user_id = 1; // 消息发送方
  required uint64 to_session_id = 2; // 消息接受方，单聊用户ID，群聊群ID
  required string msg_id = 3;        // 客户端消息ID，唯一（UUID）
  required uint64 create_time = 4;         // 消息创建时间戳(毫秒)
  required CIMDef.CIMMsgType msg_type = 5; // 消息类型
  required bytes msg_data = 6;             // 消息内容
}

// 消息错误码
enum CIMResCode {
  kCIM_RES_CODE_OK = 0; // 一切正常
  // kCIM_RES_CODE_ERROR = 1;           // 错误
  // kCIM_RES_CODE_Group_NOT_EXIST = 2; // 群不存在
  // kCIM_RES_CODE_IN_BLACK = 3;        // 被接收方加入黑名单
}

// 会话类型
enum CIMSessionType {
  // kCIM_SESSION_TYPE_Invalid = 0;   // 无效会话
  kCIM_SESSION_TYPE_SINGLE = 1; // 单聊
  kCIM_SESSION_TYPE_GROUP = 2;  // 群聊
  // kCIM_SESSION_TYPE_CHAT_ROOM = 3; // 聊天室
  // kCIM_SESSION_TYPE_CONSULT = 4; // 客服
}

// 消息类型
enum CIMMsgType {
  kCIM_MSG_TYPE_TEXT = 1;  // 文本
  kCIM_MSG_TYPE_IMAGE = 2; // 图片
  kCIM_MSG_TYPE_Audio = 3; // 声音
  // kCIM_MSG_TYPE_VIDEO = 4;        // 视频
  // kCIM_MSG_TYPE_LOCATION = 5;     // 位置
  // kCIM_MSG_TYPE_NOTIFACATION = 6; // 系统通知（包括入群出群通知等）
  // kCIM_MSG_TYPE_FILE = 7;         // 文件
  kCIM_MSG_TYPE_TIPS = 8;  // 提醒类型
  kCIM_MSG_TYPE_Robot = 9; // 图灵机器人消息

  // kCIM_MSG_TYPE_CUSTOM = 100; // 自定义
  // kCIM_MSG_TYPE_UNKNOWN = 1000; // 未知类型消息，本地使用，发送时请勿使用
}

// 消息收到回复
message IMMsgDataAck {
  // cmd id:		0x0302
  required uint64 from_user_id = 1;    // 消息发送方
  required uint64 to_session_id = 2; // 消息接受方，单聊用户ID，群聊群ID
  required string msg_id = 3;     // 客户端消息ID，唯一（UUID）
  required CIMDef.CIMResCode res_code = 4;         // 错误码
  required CIMDef.CIMSessionType session_type = 5; // 会话类型
  optional uint64 create_time = 6;                 // 创建时间戳(毫秒)
}
```

### 2.3.5 拉消息
#### 2.3.5.1 最近聊天会话列表请求

```protobuf
// 最近聊天会话列表请求
message CIMRecentContactSessionReq {
  // cmd id:		0x0201
  required uint64 user_id = 1;
  required uint32 latest_update_time = 2; // 最后更新时间
}

// 会话信息
message CIMContactSessionInfo {
  required uint64 session_id = 1;                   // 会话id
  required CIMSessionType session_type = 2;         // 会话类型
  required CIMSessionStatusType session_status = 3; // 会话修改命令，预留
  required uint32 unread_cnt = 4;     // 该会话未读消息数量
  required uint32 updated_time = 5;   // 更新时间
  required string msg_id = 6;         // 最新一条消息的id（UUID）
  required uint64 msg_time_stamp = 7; // 最新一条消息时间戳（毫秒）
  required bytes msg_data = 8;        // 最新一条消息的内容
  required CIMMsgType msg_type = 9;   // 最新一条消息的类型
  required uint64 msg_from_user_id = 10; // 最新一条消息的发送者
  required CIMMessageStatus msg_status = 11; // 最新一条消息的状态（预留）
  optional string msg_attach = 12;  // 最新一条消息的附件（预留）
  optional string extend_data = 13; // 本地扩展字段（限制4096）
  optional bool is_robot_session = 14 [ default = false ]; // 是否为机器人会话
}

message CIMRecentContactSessionRsp {
  // cmd id:		0x0202
  required uint64 user_id = 1;
  required uint32 unread_counts = 2; // 总未读数量
  repeated CIMDef.CIMContactSessionInfo contact_session_list = 3; // 会话列表
}
```

#### 2.3.5.2 历史离线消息

```protobuf
message CIMGetMsgListReq {
  // cmd id:		0x0205
  required uint64 user_id = 1;
  required CIMDef.CIMSessionType session_type = 2;
  required uint64 session_id = 3;
  required uint64 end_msg_id = 4; // 结束服务器消息id(不包含在查询结果中)
  required uint32 limit_count = 6; // 本次查询消息的条数上线(最多100条)
}

//对于群而言，如果消息数目返回的数值小于请求的cnt,则表示群的消息能拉取的到头了，更早的消息没有权限拉取。
//如果limit_count 和 msg_list.count 不一致，说明服务器消息有缺失，需要
//客户端做一个缺失标记，避免下次再次拉取。
message CIMGetMsgListRsp {
  // cmd id:		0x0206
  required uint64 user_id = 1;
  required CIMDef.CIMSessionType session_type = 2;
  required uint64 session_id = 3;
  repeated CIMDef.CIMMsgInfo msg_list = 6; // 消息列表
}
```

# 3 存储设计
